<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TM Local Model Test</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { padding:40px; }
    #webcam-container canvas { border-radius:8px; }
    #label-container { margin-top:12px; white-space:pre-line; }
    .note { margin-top:8px; color:var(--text-color); }
  </style>
</head>
<body>
  <h2>Teachable Machine Local Model Test (강아지 vs 고양이)</h2>
  <div class="note">모델 폴더(`my_model/`)를 `tm_local_test.html`과 동일한 위치에 넣고 사용하세요.</div>
  <div style="margin-top:12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
    <div>모델 URL 또는 로컬 폴더 선택</div>
    <input id="modelInput" type="text" placeholder="https://teachablemachine.withgoogle.com/models/[ID]/ (선택)" style="width:420px; padding:6px; border-radius:6px; border:1px solid #ccc;">
    <button id="btnLoadUrl" type="button">Load Model URL</button>
    <label style="display:inline-block; padding:6px 10px; background:#eee; border-radius:6px; cursor:pointer;"><input id="localModelPicker" type="file" webkitdirectory directory multiple style="display:none;"> 로컬 모델 폴더 선택</label>
    <button id="btnStart" type="button">Start Webcam</button>
    <button id="btnStop" type="button">Stop Webcam</button>
  </div>

  <div id="webcam-container"></div>
  <div id="label-container"></div>
  <div style="margin-top:12px;">
    <input id="imageUpload" type="file" accept="image/*">
    <div id="uploadPreview" style="margin-top:8px;"></div>
  </div>

  <div style="margin-top:14px;">
    <div style="margin-bottom:6px; font-weight:600;">모델 파일 직접 업로드 (model.json, metadata.json, *.bin 파일들 선택)</div>
    <input id="modelFilesPicker" type="file" accept=".json,.bin" multiple>
    <div class="note">참고: 브라우저의 tmImage.build에 따라 tmImage.loadFromFiles가 없을 수 있습니다. 실패 시 my_model 폴더 또는 원격 URL을 사용하세요.</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
  <script type="text/javascript">
    // variables
    let model, webcam, labelContainer, maxPredictions;
    let modelBaseURL = './my_model/'; // default local path

    async function loadModelFromURL(url){
      const modelURL = url + (url.endsWith('/')? 'model.json':'/model.json');
      const metadataURL = url + (url.endsWith('/')? 'metadata.json':'/metadata.json');
      model = await tmImage.load(modelURL, metadataURL);
      maxPredictions = model.getTotalClasses();
      labelContainer = document.getElementById('label-container');
      labelContainer.innerHTML = '';
      for (let i = 0; i < maxPredictions; i++) labelContainer.appendChild(document.createElement('div'));
      document.getElementById('uploadPreview').innerText = '모델 로드 완료. 웹캠 또는 이미지 업로드로 테스트하세요.';
    }

    // fallback: load default local model
    async function loadDefaultModel(){
      try{ await loadModelFromURL(modelBaseURL); }catch(e){ console.error(e); alert('로컬 모델 로드 실패. 모델 폴더가 맞는지 확인하세요.'); }
    }

    // Start webcam
    async function startWebcam(){
      if(!model){ alert('먼저 모델을 로드하세요 (URL 또는 로컬 모델).'); return; }
      if(webcam && webcam.playing) return;
      const flip = true;
      webcam = new tmImage.Webcam(320, 240, flip);
      await webcam.setup(); await webcam.play();
      document.getElementById('webcam-container').innerHTML='';
      document.getElementById('webcam-container').appendChild(webcam.canvas);
      requestAnimationFrame(camLoop);
    }

    function stopWebcam(){ if(webcam){ webcam.stop(); document.getElementById('webcam-container').innerHTML=''; }}

    async function camLoop(){ if(!webcam) return; webcam.update(); await predictFromCanvas(webcam.canvas); requestAnimationFrame(camLoop); }

    async function predictFromCanvas(canvas){ if(!model) return; const prediction = await model.predict(canvas); prediction.sort((a,b)=>b.probability-a.probability); const out = prediction.map(p=>`${p.className}: ${(p.probability*100).toFixed(1)}%`).join('\n'); document.getElementById('label-container').textContent = out; return prediction; }

    // image upload prediction
    document.getElementById('imageUpload').addEventListener('change', async (ev)=>{
      const file = ev.target.files[0]; if(!file) return;
      const img = new Image(); const url = URL.createObjectURL(file);
      img.onload = async ()=>{
        const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; const ctx = canvas.getContext('2d'); ctx.drawImage(img,0,0);
        document.getElementById('uploadPreview').innerHTML = ''; document.getElementById('uploadPreview').appendChild(img);
        await predictFromCanvas(canvas);
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    // UI bindings
    document.getElementById('btnLoadUrl').addEventListener('click', async ()=>{
      const val = document.getElementById('modelInput').value.trim();
      if(!val) return alert('모델 URL을 입력하세요 (또는 로컬 모델 사용).');
      try{ await loadModelFromURL(val); }catch(err){ console.error(err); alert('모델 로드 실패: '+err.message); }
    });

    document.getElementById('btnStart').addEventListener('click', ()=>{ startWebcam().catch(e=>console.error(e)); });
    document.getElementById('btnStop').addEventListener('click', ()=>{ stopWebcam(); });

    // local folder picker: not reliable in browsers to load via file list; show instruction
    document.getElementById('localModelPicker').addEventListener('change', (e)=>{
      document.getElementById('uploadPreview').innerText = '브라우저는 폴더 선택으로 자동 로드할 수 없습니다. my_model 폴더를 tm_local_test.html과 동일 위치에 복사하세요.';
    });

    // model files picker: build blob-URL-backed model.json + metadata then load
    document.getElementById('modelFilesPicker').addEventListener('change', async (e)=>{
      const files = Array.from(e.target.files || []);
      if(files.length === 0) return;
      document.getElementById('uploadPreview').innerText = '모델 파일 로드 중...';
      try{
        // find model.json
        const modelFile = files.find(f=>/model\.json$/i.test(f.name));
        if(!modelFile) throw new Error('model.json 파일을 찾을 수 없습니다.');

        // find metadata if present
        const metadataFile = files.find(f=>/metadata\.json$/i.test(f.name));

        // create blob URLs for all files (including .bin)
        const blobUrlMap = {};
        for(const f of files){ blobUrlMap[f.name] = URL.createObjectURL(f); }

        // read and patch model.json to point to blob URLs for weight files
        const modelText = await modelFile.text();
        const modelJson = JSON.parse(modelText);
        if(modelJson.weightsManifest && Array.isArray(modelJson.weightsManifest)){
          for(const manifest of modelJson.weightsManifest){
            if(Array.isArray(manifest.paths)){
              for(let i=0;i<manifest.paths.length;i++){
                const orig = manifest.paths[i];
                const name = orig.split('/').pop();
                if(blobUrlMap[name]) manifest.paths[i] = blobUrlMap[name];
              }
            }
          }
        }

        // create blob URL for modified model.json
        const patchedModelBlob = new Blob([JSON.stringify(modelJson)], {type:'application/json'});
        const patchedModelURL = URL.createObjectURL(patchedModelBlob);

        // create blob URL for metadata (if provided) or null
        let metadataURL = null;
        if(metadataFile){ metadataURL = URL.createObjectURL(metadataFile); }

        // load model using tmImage.load with blob URLs
        model = await tmImage.load(patchedModelURL, metadataURL);

        // set up labels
        maxPredictions = model.getTotalClasses();
        labelContainer = document.getElementById('label-container');
        labelContainer.innerHTML = '';
        for (let i = 0; i < maxPredictions; i++) labelContainer.appendChild(document.createElement('div'));

        document.getElementById('uploadPreview').innerText = '모델 업로드로 로드 완료. 이제 웹캠 또는 이미지 업로드로 테스트하세요.';

        // store blob URLs to revoke later when page unloads
        window.__tm_blob_urls = window.__tm_blob_urls || [];
        Object.values(blobUrlMap).forEach(u=>window.__tm_blob_urls.push(u));
        window.__tm_blob_urls.push(patchedModelURL);
        if(metadataURL) window.__tm_blob_urls.push(metadataURL);

      }catch(err){
        console.error('model file load failed:', err);
        document.getElementById('uploadPreview').innerText = '모델 파일 업로드로 로드하지 못했습니다. my_model 폴더 또는 URL 방식을 사용하세요.';
        alert('모델 파일 로드 실패: '+(err.message||err));
      }
    });

    // revoke created blob URLs on page unload
    window.addEventListener('unload', ()=>{
      if(window.__tm_blob_urls){ window.__tm_blob_urls.forEach(u=>URL.revokeObjectURL(u)); }
    });

    // Try default local model at load (non-blocking)
    (async ()=>{ try{ await loadDefaultModel(); }catch(e){ /* ignore */ } })();

    // Pre-fill with user-provided remote model and try auto-loading it
    (async ()=>{
      try{
        const preset = 'https://teachablemachine.withgoogle.com/models/bqtcKlKOT/';
        document.getElementById('modelInput').value = preset;
        await loadModelFromURL(preset);
      }catch(err){
        console.warn('Auto-load preset model failed:', err);
        // don't alert user to avoid double messages; page shows uploadPreview state
        document.getElementById('uploadPreview').innerText = '원격 모델 자동로드 실패(콘솔 확인). URL을 확인하거나 Load Model URL 버튼을 클릭하세요.';
      }
    })();
  </script>
</body>
</html>